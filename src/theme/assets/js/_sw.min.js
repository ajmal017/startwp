const VERSION = '{%VERSION%}';

self.addEventListener('install', event => {
  event.waitUntil(async function() {
    const cache = await caches.open('bitstarter');
    await cache.addAll([
      `${IondigitalSW.templateUrl}/assets/fonts/fontawesome/fontawesome-webfont.woff2`,
      `${IondigitalSW.templateUrl}/assets/fonts/fontawesome/fontawesome-webfont.ttf`,
      `/`
    ].map(url => new Request(url, {credentials: "include"})));

    await Promise.all([
      'https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js',
    ]
      .map(url => new Request(url, {mode: 'no-cors'}))
      .map(async req => await cache.put(req, await fetch(req)))
    );
    return self.skipWaiting();
  }());
});


self.onactivate = event => {
  event.waitUntil(self.clients.claim());
}

self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);
  const sameOrigin = url.origin === location.origin;
  //const cache = await caches.open('bitstarter');

  // if (url.href == new URL('/', location).href) {
   
  //     const resp  = await cache.match('/').catch( _ => {});
  //     const body =  await resp.text();
      
  //     const regex = /WebFont\.load\([^[]+\[(('([^\']+)\'\,?)+)/g;
  //     const regex1 = /url\(([^\)]+)/g;
  //     let m, shBody;
  //     m = regex.exec(body);
  //     let fontFamilies = m[1].split(',').map(f => f.substring(1, f.length - 1 ))
  //     let fontApiUrlBuilder = new FontApiUrlBuilder();
  //     fontApiUrlBuilder.setFontFamilies(fontFamilies);
  //     let sh = await fetch(fontApiUrlBuilder.build()).catch( _ => {});
  //     shBody =  await sh.text();
  //     while ((m = regex1.exec(shBody)) !== null) {
  //         // This is necessary to avoid infinite loops with zero-width matches
  //         if (m.index === regex.lastIndex) {
  //             regex.lastIndex++;
  //         }
          
  //         // The result can be accessed through the `m`-variable.
  //         m.forEach(async (match, groupIndex) => {
  //             if(groupIndex === 1){
  //               console.log(`Found match, group ${groupIndex}: ${match}`);
  //               const networkResponse = await fetch(match).catch(_ => {});
  //               await cache.put(match, networkResponse.clone());
  //             }
  //         });
  //     }

  //     return;
    
  // }
  if( isAssetRequest(event) || isPluginRequest(event) || isCrossOriginRequest(event))
    event.respondWith(
      caches.match(event.request).then(response => {
        return response || fetch(event.request);
      })
    );

  
});


async function staleWhileRevalidate(request, event) {
  const networkResponsePromise = fetch(request).catch(_ => {});
  const cacheResponsePromise = caches.match(request);

  // Update cache
  // event.waitUntil(async function () {
  //   const cacheName = await extractCacheName(request.url, event);
  //   const cache = await caches.open(cacheName);
  //   const networkResponse = await networkResponsePromise;
  //   const cacheResponse = await cacheResponsePromise;
  //   if(networkResponse && cacheResponse) {
  //     const changed = networkResponse.headers.get('Etag') !== cacheResponse.headers.get('Etag');
  //     if(changed) console.log('changed');
  //   }
  //   if(networkResponse) {
  //      cache.put(request, networkResponse.clone());
  //   }
  // }());

  // Determine response
  const cacheResponse = await cacheResponsePromise;
  if (cacheResponse) return cacheResponse.clone();
  const networkResponse = await networkResponsePromise;
  if(networkResponse) return networkResponse.clone();
  throw new Error(`Neither network nor cache had a response for ${request.url}`);
}


function needsSmallHeader(event) {
  return new URL(event.request.url).pathname !== '/';
}

function isCrossOriginRequest(event) {
  return new URL(event.request.url).hostname !== new URL(IondigitalSW.templateUrl).hostname;
}

function isFragmentRequest(event) {
  return new URL(event.request.url).searchParams.get('fragment') === 'true';
}

function isAssetRequest(event) {
  return /(jpe?g|png|css|svg|js|woff)$/i.test(event.request.url)
    || event.request.url.endsWith('manifest.php');
}

function isPluginRequest(event) {
  return new URL(event.request.url).pathname.startsWith('/wp-content/plugins');
}

function isWpRequest(event) {
  const parsedUrl = new URL(event.request.url);
  return parsedUrl.pathname.startsWith('/wp-') && !parsedUrl.pathname.startsWith('/wp-content');
}

function isCustomizerRequest(event) {
  return new URL(event.request.url).searchParams.has('customize_changeset_uuid');
}

function isCommentRequest(event) {
  return event.request.method === 'POST' &&
    new URL(event.request.url).pathname === '/wp-comments-post.php';
}


async function extractCacheName(url, event) {
  if(url.startsWith(IondigitalSW.templateUrl))
    return 'pwp';

  const client = await self.clients.get(event.clientId);
  if(client) {
    url = client.url;
  }
  return `pwp_pathid_${new URL(url).pathname.split('/').filter(s => !!s).join('_')}`;
}

function postComment(event) {
  if(!_bgSyncManager.supportsBackgroundSync) return;

  event.waitUntil(async function() {
    const referrer = new URL(event.request.referrer);
    event.respondWith(new Response(null, {status: 302, headers: {"Location": referrer.pathname}}));
    await _bgSyncManager.enqueue(event.request);
    await _bgSyncManager.trigger();
  }());
}


var FontApiUrlBuilder = function(apiUrl = 'https://fonts.googleapis.com/css', text = '') {
  this.apiUrl_ = apiUrl;
  this.fontFamilies_ = [];
  this.subsets_ = [];
  this.text_ = text;
};


FontApiUrlBuilder.prototype.setFontFamilies = function(fontFamilies) {
  this.parseFontFamilies_(fontFamilies);
};


  FontApiUrlBuilder.prototype.parseFontFamilies_ =
      function(fontFamilies) {
    var length = fontFamilies.length;

    for (var i = 0; i < length; i++) {
      var elements = fontFamilies[i].split(':');

      if (elements.length == 3) {
        this.subsets_.push(elements.pop());
      }
      var joinCharacter = '';
      if (elements.length == 2 && elements[1] != ''){
        joinCharacter = ':';
      }
      this.fontFamilies_.push(elements.join(joinCharacter));
    }
  };


  FontApiUrlBuilder.prototype.webSafe = function(string) {
    return string.replace(/ /g, '+');
  };


  FontApiUrlBuilder.prototype.build = function() {
    if (this.fontFamilies_.length == 0) {
      throw new Error('No fonts to load!');
    }
    if (this.apiUrl_.indexOf("kit=") != -1) {
      return this.apiUrl_;
    }
    var length = this.fontFamilies_.length;
    var sb = [];

    for (var i = 0; i < length; i++) {
      sb.push(this.webSafe(this.fontFamilies_[i]));
    }
    var url = this.apiUrl_ + '?family=' + sb.join('%7C'); // '|' escaped.

    if (this.subsets_.length > 0) {
      url += '&subset=' + this.subsets_.join(',');
    }

    if (this.text_.length > 0) {
      url += '&text=' + encodeURIComponent(this.text_);
    }

    return url;
  };


